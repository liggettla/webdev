# SQL {#sql}

## Intro
SQL stands for structured query language that is designed to facilitate accessing data that is structured into table form. PostgreSQL is a version of SQL that is used in these notes.

## Installation
The method I can easily get to work is by installing through `apt`.
```{bash eval=FALSE}
sudo apt-get install postgresql postgresql-client
```
Both the default database user and default database are called postgres, so switch to that user.
```{bash eval=FALSE}
sudo -u postgres bash
```
Then start a server.
```{bash eval=FALSE}
psql
```

I have not been able to get the installation working through a conda install but here is the reference to postgresql.
```{bash eval=FALSE}
conda install -c conda-forge postgresql
```

## Creating a Database
Note that reserved words are all being capitalized below, but this is not required, but rather a stylistic choice.

Below is the general syntax to create a PostgreSQL database.  
The `id` is being used in a manner similar to an index that will just number each of the items.  
The next three lines are all different data, and are of types `VARCHAR` and `INTEGER`.  
The `NOT NULL` aspect will cause the server to reject the entry if some data is added to the database but that value is not included.
```{bash eval=FALSE}
CREATE TABLE flights (           
    id SERIAL PRIMARY KEY,       
    origin VARCHAR NOT NULL,     
    destination VARCHAR NOT NULL,
    duration INTEGER NOT NULL    
);                               
```

Display the currently created databases.
```{bash eval=FALSE}
\d
```

Insert data into the flights database.
```{bash eval=FALSE}
INSERT INTO flights (origin, destination, duration) VALUES ('New York', 'London', 415);
```

Select all the data from flights.
```{bash eval=FALSE}
SELECT * FROM flights;
```

Select only the origin and destination columns from flights.
```{bash eval=FALSE}
SELECT origin, destination FROM flights;
```

Select only the data in flights where the id is 3.
```{bash eval=FALSE}
SELECT * FROM flights WHERE id = 3;
```

Select only the data in flights that have an origin of New York.
```{bash eval=FALSE}
SELECT * FROM flights WHERE origin = 'New York';
```

Boolean logic data selection from flights.
```{bash eval=FALSE}
SELECT * FROM flights WHERE destination = 'Paris' AND duration > 500;
```

Average a column of data.
```{bash eval=FALSE}
SELECT AVG(duration) FROM flights;
```

Combine boolean logic with calculations performed on the data.
```{bash eval=FALSE}
SELECT AVG(duration) FROM flights WHERE origin = 'New York';
```

Count columns of matching data.
```{bash eval=FALSE}
SELECT COUNT(*) FROM flights;
```

Select matching data from a list.
```{bash eval=FALSE}
SELECT * FROM flights WHERE origin IN ('New York', 'Lima');
```

Wildcards can be used to search for substrings.
```{bash eval=FALSE}
SELECT * FROM flights WHERE origin LIKE '%a%';
```

SQL uses `LIMIT` to function like `HEAD`.
```{bash eval=FALSE}
SELECT * FROM flights LIMIT 2;
```

Order data in ascending order `asc` is ascending and `desc` is for descending.
```{bash eval=FALSE}
select * from flights order by duration asc;
```

Data can be grouped together as in pandas.  
The following code selects the origin column, counts the number of identical origin entries and then adds this count to a new count column.
```{bash eval=FALSE}
select origin, count(*) from flights group by origin;
```

Grouped data counts can be immedately filtered when searching.
```{bash eval=FALSE}
SELECT origin, COUNT(*) FROM flights GROUP BY origin HAVING COUNT(*) > 1;
```

## Updating Data

This will change the duration of the flight from New York to London to 430.
```{bash eval=FALSE}
UPDATE flights
SET duration = 430
WHERE origin = 'New York'
AND destination = 'London';
```

Delete a set of matching data from a database.
```{bash eval=FALSE}
DELETE FROM flights
WHERE destination = 'Tokyo';
```

## Join/Merge
Inner join is the default join and will only include data that is matched.

Foreign keys can be used to reference the data within another table so that data does not need to be continually repeated. For instance if a number of flights are all heading to New York, the city id could be set as number 1 and then flight destination ids could be just set to 1.  
As an example, the following table can be created that has passenger names, and in the `flight_id` column, the `flights` database is reference to get the actual flight locations.  
When one database references another as in the following code, the referenced column is typically the `PRIMARY KEY`, thought this can be modified if necessary.
```{bash eval=FALSE}
CREATE TABLE passengers(
    id SERIAL PRIMARY KEY,
    name VARCHAR NOT NULL,
    flight_id INTEGER REFERENCES flights);
```

It might be helpful to add some data to the above database for testing, so here is some data.
```{bash eval=FALSE}
INSERT INTO passengers (name, flight_id) VALUES ('Alice', 1);  
INSERT INTO passengers (name, flight_id) VALUES ('Bob', 1);    
INSERT INTO passengers (name, flight_id) VALUES ('Charlie', 2);
INSERT INTO passengers (name, flight_id) VALUES ('Dave', 2);   
INSERT INTO passengers (name, flight_id) VALUES ('Erin', 4);   
INSERT INTO passengers (name, flight_id) VALUES ('Frank', 6);  
INSERT INTO passengers (name, flight_id) VALUES ('Grace', 6);  
```

In order to reference the id data from the `flights` database for instance and match that up with the data found in the `passengers` database, the databases should can be joined on the id columns that correspond with each other, in an analogous manner as is performed in pandas.  
The following code selects the `origin` and `destination` columns from the `flights` database, and the `name` column from the `passengers` database, after the two databases have been joined on their respective flight id columns.
```{bash eval=FALSE}
SELECT origin, destination, name FROM flights JOIN passengers ON passengers.flight_id = flights.id;
```

Data can be directly selected when merging two databases together like the following selection of on the data corresponding with the passenger named `Alice`.
```{bash eval=FALSE}
SELECT origin, destination, name FROM flights JOIN passengers ON passengers.flight_id = flights.id WHERE name = 'Alice';
```

Left/right joining of databases can be performed that unlike inner join will include all of the data in the left or right database.
```{bash eval=FALSE}
SELECT origin, destination, name FROM flights left JOIN passengers ON passengers.flight_id = flights.id WHERE name = 'Alice';
```

## Indexing
Indexing allows a subset of one database (sort of like a pandas series) to be used to select data from a database (analogous to a DataFrame).  
In the following code, within the parentheses the `flight_id` column is being selected to create a "series", and the ids are being grouped by `passengers`, and only those flights have more than one passenger are included within the "series". This series of flight ids is then used to filter the original `flights` "DataFrame".
```{bash eval=FALSE}
select * from flights where id in (select flight_id from passengers group by flight_id having count(*) > 1);
```

## SQL Injection
User input should be escaped or sanitized to prevent a user from inputting SQL code into input fields and have it be directly executed as SQL.  
As an example if a username and password field are presented to the user, and the input is checked against a SQL database, it might look something like the following.
```{bash eval=FALSE}
SELECT * FROM users WHERE (username = 'Bill') AND (password = '12345')
```

The problem with the above code is that SQL code could theoretically be entered into the fields like the following.  
If `1', OR '1' = '1'` is entered into the password field, now the SQL query would looks something like the following, which evaluates as True and may allow somebody access to the database.
```{bash eval=FALSE}
SELECT * FROM users WHERE (username = 'Bill') AND (password = '1', OR '1' = '1')
```

## Transactions and Race Conditions
This refers to a challenge if multiple requests simultaneously are made to the same data within a database and an attempt to modify the database occurs. The problem is that if the requests conflict in some manner the database can be improperly altered. One solution to this is transactions, where one user essentially checks-out the database and can modify it, and the second user can only modify the database after the first user as completed interacting with the database.

## SQLAlchemy
SQLAlchemy is a python library that can be used to interact with SQL data.  
The library can be installed like this:
```{bash eval=FALSE}
conda install -c conda-forge sqlalchemy sqlalchemy-utils
```


